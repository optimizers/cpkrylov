% CPKRYLOV EXAMPLE PROGRAM 2
%
%==========================================================================
% August 23, 2019.
% Daniela di Serafino, daniela.diserafino@unicampania.it.
% Dominique Orban, dominique.orban@gerad.ca.
%
%==========================================================================
%
% This program runs CP-GMRES (or CP-DQGMRES) on a nonsymmetric
% saddle-point linear system whose matrix has the form
%
%                     [ H+rho*I    0     0 |    J1'   ]     
%       [ Q |  A']    [    0     rho*I  -I |    J2'   ]
%   K = ----------  = [    0       Z     S |     0    ],
%       [ A | -C ]    ---------------------|----------- 
%                     [   J1      J2     0 | -delta*I ]
%
% where
% - Q is nonsymmetric and n x n,
% - A is m x n, with m <= n,
% - C is m x m.
%
% The matrix satisfies additional conditions, as explained in
%   D. di Serafino and D. Orban,
%   Constraint-Preconditioned Krylov Solvers for Regularized
%   Saddle-Point Systems,
%   Cahier du GERAD G-2019-72, GERAD, Montreal, October 2019.
%
% The linear system is obtained by permuting the matrix and the rhs of a
% nonsymmetric system coming from a collection of regularized saddle-point
% systems, generated by applying a primal-dual regularized interior point
% method to quadratic programming problems from CUTEst.
% See
%   D. Orban,
%   A collection of linear systems arising from interior-point methods for
%   quadratic optimization,
%   Cahier du GERAD G-2015-117, GERAD, Montréal, QC, Canada,
% for a description of the collection and details on the matrix K reported
% above.
%
%==========================================================================

% Load saddle-point system (problem mosarqp2, interior point iter 5)
filename = 'cvxqp2_s_3x3_nonsymm_perm_iter10.mat';
load(filename);               % load K, n=dim(K), nH, nJ, nZ, rhs
n = nH + nZ;
m = nJ;
clear nH nJ nZ;

fprintf('\n\n==================================================================');
fprintf('\n                   cpkrylov example program 2');
fprintf('\n==================================================================\n');
fprintf('\nnonsymmetric saddle-point system from');
fprintf('\n- quadratic programming problem cvxqp2-s (n = %d, m = %d)', n, m);
fprintf('\n- interior point iteration 10\n');

% Build constraint preconditioner
Q = K(1:n,1:n);
dd = spdiags(Q, 0);
G = spdiags(dd, 0, n, n);
A = K(n+1:end,1:n);
C = - K(n+1:end,n+1:end);
CP = [G  A'; A -C];
    
% Choose solver
cpk = @cpgmres;
opts.restart = 100;     % restart for GMRES
cpkstring = strcat('CP-GMRES(', sprintf('%d', opts.restart), ')');
% cpk = @cpdqgmres;
% opts.mem = 100;         % memory for DQGMRES
% cpkstring = strcat('CP-DQGMRES(', sprintf('%d', opts.mem), ')');
fprintf('\n**************************** %s ***************************\n', cpkstring);
        
% Set further solver options
% Some options are set to default values -- we can avoid their explicit setup
opts.print = false;     % display info during execution
opts.atol = 1.0e-6;     % abs tol for stop criterion (default)
opts.rtol = 1.0e-6;     % rel tol for stop criterion (default)
opts.itmax = 500;      % max num solver iterations
fprintf('\natol = %8.2e,  rtol = %8.2e,  itmax = %d', ...
    opts.atol, opts.rtol, opts.itmax);

% Set options for residual update and iterative refinement
opts.residual_update = true; % use residual update
opts.nitref = 1;             % max # iterative refinement steps
opts.force_itref = true;     % force iterative refinement
opts.itref_tol = 1.0e-8;     % rel tol for iterative refinement (default)
fprintf('\nresidual_update = %d,  nitref = %d,  force_iref = %d,  itref_tol = %7.1e\n', ...
        opts.residual_update, opts.nitref, opts.force_itref, opts.itref_tol);
    
% Call CP-Krylov solver.
ts = tic;
[cpkx,  cpkstats, cpkflag] = reg_cpkrylov(cpk, rhs, Q, A, C, G, opts);
ttot = toc(ts);

% Solve K*x = rhs with a direct method (for comparison)
x = K \ rhs;

% Print error and other info
fprintf('\n2-norm relative error in the solution = %8.2e', norm(x-cpkx)/norm(x));
fprintf('\niters = %d,  solved (1 yes, 0 no) = %d', cpkstats.niters, cpkflag.solved);
fprintf('\ntime (prec setup, solve, reg_cpkrylov) = %9.3e,  %9.3e,  %9.3e\n\n', ...
        cpkstats.ptime, cpkstats.stime, ttot);
    
% Print residual norm history
fig = figure;
semilogy(0: size(cpkstats.residHistory,1)-1, cpkstats.residHistory, 'b-.', ...
    'LineWidth', 2);
legend(cpkstring, 'fontsize', 14);
xlabel('iters');
ylabel('||res||');
title('residual history (cvxqp2-s, ip iter 10, nonsymm matrix)');
set(gca, 'fontsize', 14);

